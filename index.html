<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Camera Viewer</title>
    <style>
        body { background-color: #1a1a1a; margin: 0; font-family: sans-serif; color: #ccc; }
        #grid-container {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(4, 1fr);
            height: 100vh;
            gap: 5px;
            padding: 5px;
            box-sizing: border-box;
        }
        .grid-item { 
            background-color: #000; 
            position: relative; 
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        video { width: 100%; height: 100%; object-fit: cover; }
        .overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: rgba(0,0,0,0.7);
            font-size: 1.2em;
            text-align: center;
            padding: 10px;
            transition: opacity 0.3s ease;
        }
        .overlay.hidden { display: none; }
        .cam-title {
            position: absolute; top: 5px; left: 5px;
            color: white; background-color: rgba(0,0,0,0.6);
            padding: 2px 8px; border-radius: 3px; font-size: 14px;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
</head>
<body>
    <div id="grid-container"></div>

    <script>
        const grid = document.getElementById('grid-container');
        const totalCameras = 16;
        const USE_WEBRTC = true; // Change to false to use HLS
        const DEBUG = false; // Set to true for development logging

        // Debug logging helpers
        const log = DEBUG ? console.log.bind(console) : () => {};
        const warn = DEBUG ? console.warn.bind(console) : () => {};
        const error = console.error.bind(console); // Always log errors

        // Utility: Wait for ICE gathering with timeout
        function waitForIceGatheringWithTimeout(pc, timeout = 10000) {
            return Promise.race([
                new Promise((resolve) => {
                    if (pc.iceGatheringState === 'complete') {
                        resolve();
                    } else {
                        const checkState = () => {
                            if (pc.iceGatheringState === 'complete') {
                                pc.removeEventListener('icegatheringstatechange', checkState);
                                resolve();
                            }
                        };
                        pc.addEventListener('icegatheringstatechange', checkState);
                    }
                }),
                new Promise((_, reject) =>
                    setTimeout(() => reject(new Error('ICE gathering timeout')), timeout)
                )
            ]);
        }

        // Utility: Cleanup WebRTC resources
        function cleanupWebRTC(pc, video) {
            if (pc) {
                pc.close();
            }
            if (video.srcObject) {
                video.srcObject.getTracks().forEach(track => track.stop());
                video.srcObject = null;
            }
        }

        async function startWebRTC(video, streamName, loadingOverlay, errorOverlay) {
            let pc = null;

            try {
                pc = new RTCPeerConnection({
                    iceServers: [{urls: 'stun:stun.l.google.com:19302'}]
                });

                pc.addTransceiver('video', {direction: 'recvonly'});
                pc.addTransceiver('audio', {direction: 'recvonly'});

                pc.ontrack = async (event) => {
                    video.srcObject = event.streams[0];
                    try {
                        await video.play();
                        loadingOverlay.classList.add('hidden');
                        log(`${streamName}: Video playback started`);
                    } catch (playError) {
                        error(`${streamName}: Autoplay blocked:`, playError);
                        // Show user interaction prompt
                        errorOverlay.textContent = 'Click to Start Stream';
                        errorOverlay.classList.remove('hidden');
                        errorOverlay.style.cursor = 'pointer';
                        loadingOverlay.classList.add('hidden');

                        errorOverlay.onclick = async () => {
                            try {
                                await video.play();
                                errorOverlay.classList.add('hidden');
                                errorOverlay.onclick = null;
                                errorOverlay.style.cursor = 'default';
                                log(`${streamName}: Video started after user interaction`);
                            } catch (e) {
                                error(`${streamName}: Playback failed:`, e);
                                errorOverlay.textContent = 'Playback Failed';
                                errorOverlay.style.cursor = 'default';
                            }
                        };
                    }
                };

                pc.oniceconnectionstatechange = () => {
                    const state = pc.iceConnectionState;
                    log(`${streamName}: ICE connection state: ${state}`);

                    if (state === 'failed' || state === 'disconnected' || state === 'closed') {
                        error(`${streamName}: ICE connection ${state}`);
                        errorOverlay.textContent = `Connection ${state}`;
                        errorOverlay.classList.remove('hidden');
                        loadingOverlay.classList.add('hidden');
                        cleanupWebRTC(pc, video);
                    }
                };

                // Create offer and wait for ICE gathering to complete
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);

                // Wait for ICE gathering to complete with timeout
                await waitForIceGatheringWithTimeout(pc);
                log(`${streamName}: ICE gathering complete`);

                // Now send the complete SDP with ICE candidates
                const response = await fetch(`http://${window.location.hostname}:1984/api/webrtc?src=${streamName}`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/sdp'},
                    body: pc.localDescription.sdp
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${await response.text()}`);
                }

                const answer = await response.text();
                await pc.setRemoteDescription({type: 'answer', sdp: answer});

                log(`${streamName}: WebRTC connected`);
            } catch (err) {
                error(`${streamName} WebRTC error:`, err);
                errorOverlay.textContent = 'Stream Offline\n(Check Logs)';
                errorOverlay.classList.remove('hidden');
                loadingOverlay.classList.add('hidden');
                cleanupWebRTC(pc, video);
                throw err; // Re-throw for retry logic
            }
        }

        function startHLS(video, streamName, loadingOverlay, errorOverlay) {
            const hlsUrl = `/hls/${streamName}/stream.m3u8`;

            if (Hls.isSupported()) {
                const hls = new Hls({
                    maxBufferLength: 4,
                    maxMaxBufferLength: 8,
                    liveSyncDuration: 1,
                    liveMaxLatencyDuration: 5,
                    liveDurationInfinity: true,
                    enableWorker: true,
                    lowLatencyMode: true
                });
                hls.loadSource(hlsUrl);
                hls.attachMedia(video);

                hls.on(Hls.Events.MANIFEST_PARSED, async function() {
                    try {
                        await video.play();
                        loadingOverlay.classList.add('hidden');
                        log(`${streamName}: HLS playback started`);
                    } catch (playError) {
                        error(`${streamName}: HLS autoplay blocked:`, playError);
                        errorOverlay.textContent = 'Click to Start';
                        errorOverlay.classList.remove('hidden');
                        errorOverlay.style.cursor = 'pointer';
                        loadingOverlay.classList.add('hidden');

                        errorOverlay.onclick = async () => {
                            try {
                                await video.play();
                                errorOverlay.classList.add('hidden');
                                errorOverlay.onclick = null;
                                errorOverlay.style.cursor = 'default';
                            } catch (e) {
                                error(`${streamName}: HLS playback failed:`, e);
                                errorOverlay.textContent = 'Playback Failed';
                            }
                        };
                    }
                });
                hls.on(Hls.Events.ERROR, function(event, data) {
                    if (data.fatal) {
                        error(`${streamName}: HLS fatal error:`, data);
                        loadingOverlay.classList.add('hidden');
                        errorOverlay.textContent = 'Stream Offline\n(Check Logs)';
                        errorOverlay.classList.remove('hidden');
                    }
                });
            } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
                video.src = hlsUrl;
                video.addEventListener('loadedmetadata', async function() {
                    try {
                        await video.play();
                        loadingOverlay.classList.add('hidden');
                    } catch (playError) {
                        error(`${streamName}: Native HLS autoplay blocked:`, playError);
                        errorOverlay.textContent = 'Click to Start';
                        errorOverlay.classList.remove('hidden');
                        loadingOverlay.classList.add('hidden');
                    }
                });
            }
        }

        // Retry wrapper for WebRTC with exponential backoff
        async function startWebRTCWithRetry(video, streamName, loadingOverlay, errorOverlay, maxRetries = 3) {
            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                    await startWebRTC(video, streamName, loadingOverlay, errorOverlay);
                    return; // Success - exit retry loop
                } catch (err) {
                    error(`${streamName}: Attempt ${attempt}/${maxRetries} failed`);

                    if (attempt < maxRetries) {
                        const delay = Math.min(1000 * Math.pow(2, attempt - 1), 10000);
                        log(`${streamName}: Retrying in ${delay}ms...`);
                        errorOverlay.textContent = `Retrying (${attempt}/${maxRetries})...`;
                        errorOverlay.classList.remove('hidden');
                        loadingOverlay.classList.add('hidden');

                        await new Promise(resolve => setTimeout(resolve, delay));

                        // Reset UI for next attempt
                        errorOverlay.classList.add('hidden');
                        loadingOverlay.classList.remove('hidden');
                        loadingOverlay.textContent = 'Reconnecting...';
                    } else {
                        // Max retries reached
                        error(`${streamName}: Max retries (${maxRetries}) reached`);
                        errorOverlay.textContent = 'Connection Failed\n(Max retries reached)';
                        errorOverlay.classList.remove('hidden');
                        loadingOverlay.classList.add('hidden');
                    }
                }
            }
        }

        for (let i = 1; i <= totalCameras; i++) {
            const item = document.createElement('div');
            item.className = 'grid-item';

            const video = document.createElement('video');
            video.id = `cam${i}`;
            video.muted = true;
            video.autoplay = true;
            video.playsinline = true;

            const title = document.createElement('div');
            title.className = 'cam-title';
            title.innerText = `Camera ${i}`;

            const loadingOverlay = document.createElement('div');
            loadingOverlay.className = 'overlay loading';
            loadingOverlay.innerText = 'Connecting Stream...';

            const errorOverlay = document.createElement('div');
            errorOverlay.className = 'overlay error hidden';
            errorOverlay.innerText = 'Stream Offline\n(Check Logs)';

            item.appendChild(video);
            item.appendChild(title);
            item.appendChild(loadingOverlay);
            item.appendChild(errorOverlay);
            grid.appendChild(item);

            const streamName = `cam${i}`;

            if (USE_WEBRTC) {
                startWebRTCWithRetry(video, streamName, loadingOverlay, errorOverlay);
            } else {
                startHLS(video, streamName, loadingOverlay, errorOverlay);
            }
        }
    </script>
</body>
</html>